/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta>
#include <mg_regsystem_api_const>
#include <sqlx>

#define PLUGIN "[MG] RegSystem API"
#define VERSION "1.0"
#define AUTHOR "Vieni"

#define TASKID1 615
#define TASKID2 4215

#define flag_get(%1,%2) (%1 & (1 << (%2 & 31)))
#define flag_set(%1,%2) %1 |= (1 << (%2 & 31))
#define flag_unset(%1,%2) %1 &= ~(1 << (%2 & 31))

new gAccountId[33], gGameTime[33]
new gLoggedIn, gAutoLogin, gLoadingUser

new Array:arrayUserLoadingSql[33]

new Handle:gSqlRegTuple

new gForwardClientSuccessLogin, gForwardClientProcessLogin, gForwardClientFailedLogin, gForwardClientClean

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)

	gForwardClientSuccessLogin = CreateMultiForward("mg_fw_client_login_success", ET_CONTINUE, FP_CELL)
	gForwardClientProcessLogin = CreateMultiForward("mg_fw_client_login_process", ET_CONTINUE, FP_CELL)
	gForwardClientFailedLogin = CreateMultiForward("mg_fw_client_login_failed", ET_CONTINUE, FP_CELL, FP_CELL)
	gForwardClientClean = CreateMultiForward("mg_fw_client_clean", ET_CONTINUE, FP_CELL)
}

public plugin_natives()
{
	gSqlRegTuple = SQL_MakeDbTuple("127.0.0.1","ebateam_forum", "z8hEn1gEUTWaSzfY","ebateam_forum")
	
	register_native("mg_reg_user_loading", "native_reg_user_loading")
	register_native("mg_reg_user_loggedin", "native_reg_user_loggedin")
	register_native("mg_reg_user_login", "native_reg_user_login")
	register_native("mg_reg_user_logout", "native_reg_user_logout")
	register_native("mg_reg_user_sqlload_start", "native_reg_user_sqlload_start")
	register_native("mg_reg_user_sqlload_finished", "native_reg_user_sqlload_finished")
}

public sqlLoginHandle(FailState, Handle:Query, error[], errorcode, data[], datasize, Float:fQueueTime)
{
	new retValue
	new id = data[0]
	
	if(FailState == TQUERY_CONNECT_FAILED || FailState == TQUERY_QUERY_FAILED)
	{
		if(flag_get(gAutoLogin, id))
		{
			log_amx("%s", error)
			flag_unset(gLoadingUser, id)
			flag_unset(gAutoLogin, id)
			ExecuteForward(gForwardClientFailedLogin, retValue, id, ERROR_DONT_NOTIFY)
			return
		}
		
		log_amx("%s", error)
		flag_unset(gLoadingUser, id)
		ExecuteForward(gForwardClientFailedLogin, retValue, id, ERROR_SQL_ERROR)
		return
	}
	
	if(SQL_NumRows(Query) <= 0)
	{
		if(flag_get(gAutoLogin, id))
		{
			flag_unset(gLoadingUser, id)
			flag_unset(gAutoLogin, id)
			ExecuteForward(gForwardClientFailedLogin, retValue, id, ERROR_DONT_NOTIFY)
			return
		}
		
		flag_unset(gLoadingUser, id)
		ExecuteForward(gForwardClientFailedLogin, retValue, id, ERROR_ACCOUNT_NOT_FOUND)
		return
	}
	
	new activeAccount = SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "accountActiveZP"))
		
	if(activeAccount)
	{
		if(flag_get(gAutoLogin, id))
		{
			flag_unset(gLoadingUser, id)
			flag_unset(gAutoLogin, id)
			ExecuteForward(gForwardClientFailedLogin, retValue, id, ERROR_DONT_NOTIFY)
			return
		}
		
		flag_unset(gLoadingUser, id)
		ExecuteForward(gForwardClientFailedLogin, retValue, id, ERROR_ACCOUNT_USED)
		return
	}
	
	if(!is_user_connected(id))
	{
		flag_unset(gLoadingUser, id)
		flag_unset(gAutoLogin, id)
		ExecuteForward(gForwardClientFailedLogin, retValue, id, ERROR_DONT_NOTIFY)
		return
	}
	
	if(flag_get(gAutoLogin, id))
	{
		new lAutoLogin = false
		
		while(SQL_MoreResults(Query) && !lAutoLogin)
		{
			new lNameSql[MAX_NAME_LENGTH+1], lSetinfoPwSql[MAX_SETINFOPW_LENGTH+1]
			
			if(SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "settingAutoLoginSteamId")))
			{
				new lSteamIdSql[MAX_AUTHID_LENGTH+1], lSteamId[MAX_AUTHID_LENGTH+1]
				
				SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "lastSteamId"), lSteamIdSql, charsmax(lSteamIdSql))
				get_user_authid(id, lSteamId, charsmax(lSteamId))
				
				if(!equal(lSteamIdSql, lSteamId))
				{
					lAutoLogin = false
					SQL_NextRow(Query)
					continue
				}
				
				lAutoLogin = true
			}
			
			if(SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "settingAutoLoginName")))
			{
				new lNameSql[MAX_NAME_LENGTH+1], lName[MAX_NAME_LENGTH+1]
				
				SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "lastName"), lNameSql, charsmax(lNameSql))
				get_user_name(id, lName, charsmax(lName))
				
				if(!equal(lNameSql, lName))
				{
					lAutoLogin = false
					SQL_NextRow(Query)
					continue
				}
				
				lAutoLogin = true
			}
			
			if(SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "settingAutoLoginSetinfoPw")))
			{
				new lSetinfoPwSql[MAX_NAME_LENGTH+1], lSetinfoPw[MAX_NAME_LENGTH+1]
				
				SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "lastSetinfoPwHash"), lSetinfoPwSql, charsmax(lSetinfoPwSql))
				getSetinfoPwHash(id, lSetinfoPw, charsmax(lSetinfoPw))
				
				if(!equal(lSetinfoPwSql, SetinfoPw))
				{
					lAutoLogin = false
					SQL_NextRow(Query)
					continue
				}
				
				lAutoLogin = true
			}
		}
		
		if(!lAutoLogin)
		{
			flag_unset(gLoadingUser, id)
			flag_unset(gAutoLogin, id)
			ExecuteForward(gForwardClientFailedLogin, retValue, id, ERROR_DONT_NOTIFY)
			return
		}
	}
	
	gAccountId[id] = SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "accountId"))
	
	new sqlText[256]
	
	formatex(sqlText, charsmax(sqlText), "UPDATE regSystemAccounts SET accountActiveZP=^"%d^" WHERE accountId=^"%d^";", true, gAccountId[id])
	SQL_ThreadQuery(gSqlRegTuple, "sqlGeneralHandle", sqlText)
	
	gGameTime[id] = SQL_ReadResult(Query, SQL_FieldNameToNum(Query, "gameTime"))
	
	ExecuteForward(gForwardClientProcessLogin, retValue, id)
	
	if(!retValue)
		ExecuteForward(gForwardClientSuccessLogin, retValue, id)
}

public saveAccountData(taskId)
{
	static id, disconnect
	id = taskId - TASKID1
	
	disconnect = false
	
	if(id > 32)
	{
		disconnect = true
		id /= 33
	}
	
	if(!flag_get(gLoggedIn, id) || flag_get(gLoadingUser, id) || !gAccountId[id])
		return
	
	static sqlText[2048]
	static len
	
	if(disconnect)
	{
		static lSteamId[MAX_AUTHID_LENGTH+1], lName[MAX_NAME_LENGTH+1], lSetinfoPwHash[MAX_SETINFOPW_LENGTH+1]
		
		lSteamId[0] = EOS
		lName[0] = EOS
		lSetinfoPwHash[0] = EOS
		
		get_user_authid(id, lSteamId, charsmax(lSteamId))
		get_user_name(id, lName, charsmax(lName))
		getSetinfoPwHash(id, lSetinfoPwHash, charsmax(lSetinfoPwHash))
	}
	
	sqlText[0] = EOS
	len = 0
	
	len += formatex(sqlText[len], charsmax(sqlText) - len, "UPDATE regSystemAccounts SET")
	len += formatex(sqlText[len], charsmax(sqlText) - len, " gameTime = ^"%d^"", gGameTime[id]+get_user_time(id, 1))
	
	if(disconnect)
		len += formatex(sqlText[len], charsmax(sqlText) - len, ", lastSteamId = ^"%s^", lastName = ^"%s^", lastSetinfoPwHash = ^"%s^"", lSteamId, lName, lSetinfoPwHash)
	
	len += formatex(sqlText[len], charsmax(sqlText) - len, " WHERE gameId=^"%d^";", gGameId[id])
	SQL_ThreadQuery(zm2(), "sqlGeneralHandle", sqlText)
	
	set_task(10.0, "sqlSaveData", TASKID1+id)
}

public sqlGeneralHandle(FailState, Handle:Query, error[],errcode, data[], datasize)
{
	if(FailState == TQUERY_CONNECT_FAILED || FailState == TQUERY_QUERY_FAILED)
	{
		log_amx("%s", error)
		return
	}
}

public checkSqlArray(taskId)
{
	new id = taskId - TASKID
	
	if(!ArraySize(arrayUserLoadingSql[id]))
	{
		ArrayDestroy(arrayUserLoadingSql[id])
		ExecuteForward(gForwardClientSuccessLogin, retValue, id)
	}
}

public native_reg_user_loading(plugin_id, param_num)
	return flag_get(gLoadingUser, get_param(1))

public native_reg_user_loggedin(plugin_id, param_num)
{
	new id = get_param(1)
	
	if(flag_get(gLoadingUser, id))
		return false
	
	return flag_get(gLoggedIn, id)
}

public native_reg_user_login(plugin_id, param_num)
{
	new id = get_param(1)
	new lUsername[33], lPassword[33]
	get_string(2, lUsername, charsmax(lUsername))
	get_string(3, lPassword, charsmax(lPassword))
	
	if(flag_get(gLoggedIn, id))
	{
		log_amx("[LOGIN] User's already logged in! (%d)", gAccountId[id])
		return false
	}
	
	if(flag_get(gLoadingUser, id))
	{
		new lName[MAX_NAME_LENGTH+1]
		
		get_user_name(id, lName, charsmax(lName))
		
		log_amx("[LOGIN] User's account is loading! (%d)", lName)
		return false
	}
	
	return userLogin(id, lUsername, lPassword)
}

public native_reg_user_logout(plugin_id, param_num)
{
	new id = get_param(1)
	
	if(!flag_get(gLoggedIn, id))
	{
		new lName[MAX_NAME_LENGTH+1]
		
		get_user_name(id, lName, charsmax(lName))
		
		log_amx("[LOGOUT] User is not logged in! (%s)", lName)
		return false
	}
	
	if(!flag_get(gLoadingUser, id))
	{
		new lName[MAX_NAME_LENGTH+1]
		
		get_user_name(id, lName, charsmax(lName))
		
		log_amx("[LOGOUT] User's account is loading! (%s)", lName)
		return false
	}
	
	userLogout(id)
	return true
}

public native_reg_user_sqlload_start(plugin_id, param_num)
{
	new id = get_param(1)
	new lSqlId = get_param(2)
	
	if(!arrayUserLoadingSql[id])
		arrayUserLoadingSql[id] = ArrayCreate(1)
	
	ArrayPushCell(arrayUserLoadingSql[id], lSqlId)
}

public native_reg_user_sqlload_finished(plugin_id, param_num)
{
	new id = get_param(1)
	new lSqlId = get_param(2)
	
	ArrayDeleteItem(arrayUserLoadingSql[id], lSqlId)
	
	remove_task(TASKID+id)
	set_task(0.5, "checkSqlArray", TASKID+id)
}

public client_putinserver(id)
{
	client_clean(id)
	flag_set(gAutoLogin, id)
	userLogin(id)
}

public client_disconnected(id)
	client_clean(id, true)

client_clean(id, bool:disconnect = false)
{
	if(disconnect)
	{
		remove_task(TASKID1+id)
		
		saveAccountData(TASKID1+(id*33))
	}
	
	new sqlText[128], retValue
	
	formatex(sqlText, charsmax(sqlText), "UPDATE regSystemAccounts SET accountActiveZP=^"%d^" WHERE accountId=^"%d^";", false, gAccountId[id])
	SQL_ThreadQuery(gSqlRegTuple, "sqlGeneralHandle", sqlText)
	
	flag_unset(gLoadingUser, id)
	flag_unset(gLoggedIn, id)
	flag_unset(gAutoLogin, id)
	gAccountId[id] = 0
	gGameTime[id] = 0
	
	remove_task(TASKID1+id)
	
	ExecuteForward(gForwardClientClean, retValue, id)
}

userLogin(id, const &username[], const &password[])
{
	if(!is_user_connected(id) || flag_get(gLoggedIn, id) || flag_get(gLoadingUser, id))
		return false
	
	flag_set(gLoadingUser, id)
	
	new lSqlTxt[250], data[1]
	
	data[0] = id
	
	if(!flag_get(gAutoLogin, id))
		formatex(lSqlTxt, charsmax(lSqlTxt), "SELECT * FROM regSystemAccounts WHERE userName=^"%s^" AND passWord=^"%s^";", username, password)
	else
	{
		new lSteamId[MAX_AUTHID_LENGTH+1], lName[MAX_NAME_LENGTH+1], lSetinfoPwHash[MAX_SETINFOPW_LENGTH+1]
		
		get_user_authid(id, lSteamId, charsmax(lSteamId))
		get_user_name(id, lName, charsmax(lName))
		getSetinfoPwHash(id, lSetinfoPwHash, charsmax(lSetinfoPwHash))
		
		formatex(lSqlTxt, charsmax(lSqlTxt), "SELECT * FROM regSystemAccounts WHERE lastSteamId=^"%s^" OR lastName=^"%s^" OR (lastSetinfoPw=^"%s^" AND lastSetinfoPw!="");", lSteamId, lName, lSetinfoPwHash)
	}
	SQL_ThreadQuery(gSqlRegTuple, "sqlLoginHandle", lSqlTxt, data, 1)
	
	return true
}

getSetinfoPwHash(id, string[], len)
{
	get_user_info(id, "_pw", string, len)
	hash_string(string, Hash_Md5, string, len)
	return true
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1066\\ f0\\ fs16 \n\\ par }
*/
